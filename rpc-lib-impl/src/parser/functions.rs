use std::vec::*;

use quote::__private::TokenStream as QuoteTokenStream;
use quote::{format_ident, quote};

use super::parser::Rule;
use super::util::*;

pub struct FunctionDef {
    pub identifier: String,
    pub return_type: String,
    pub parameter: Vec<String>,
    pub value: i32,
}

impl FunctionDef {
    pub fn from_pest(func_rule: pest::iterators::Pair<'_, Rule>) -> FunctionDef {
        let mut def = FunctionDef {
            identifier: String::new(),
            return_type: String::new(),
            parameter: Vec::new(),
            value: -1,
        };
        for func_item in func_rule.into_inner() {
            match func_item.as_rule() {
                Rule::type_ident => {
                    def.return_type = func_item.as_str().to_string();
                }
                Rule::func_ident => {
                    def.identifier = func_item.as_str().to_string();
                }
                Rule::parameter_list => {
                    for parameter in func_item.into_inner() {
                        match parameter.as_rule() {
                            Rule::built_in_type | Rule::identifier => {
                                def.parameter.push(parameter.as_str().to_string());
                            }
                            _ => {
                                panic!("Invalid Parameter in Procedure {}", def.identifier);
                            }
                        }
                    }
                }
                Rule::integer => {
                    def.value = func_item.as_str().parse::<i32>().unwrap();
                }
                _ => panic!("Invalid Syntax in Function"),
            }
        }
        def
    }

    pub fn to_rust_code(&self, version: i32) -> (QuoteTokenStream, QuoteTokenStream) {
        // Name of function
        let name = format_ident!("{}", self.identifier.to_lowercase().to_string());

        // Return-Type (Can be primtive or defined somewhere above)
        let has_ret_value = if self.return_type != "void" {
            true
        } else {
            false
        };
        let ret_type =
            convert_primitve_type(&self.return_type).unwrap_or_else(|| &self.return_type);
        // Format
        let return_type = format_ident!("{}", ret_type);

        // Procedure-Identifier (<Name>_<version>) (compatible with c-code generated by rpcgen)
        let proc_ident = format_ident!(
            "{}_{}",
            self.identifier.to_lowercase().to_string(),
            version.to_string()
        );

        // Parameter
        let mut parameter = quote!();
        let mut arg = 0;
        let mut arguments_c_call = quote!();
        let mut parameter_c_binding = quote!();
        let mut conversion_code = quote!();
        for param in &self.parameter {
            // Naming of parameter is not important!
            // Type can be primitve or already defined
            let param_type = convert_primitve_type(param).unwrap_or_else(|| param);
            let parameter_type = if param_type == "*mut c_char" {
                quote!(&str)
            } else {
                let ident = format_ident!("{}", param_type);
                quote!(#ident)
            };
            let parameter_type_c = if param_type == "*mut c_char" {
                quote!(*const c_char)
            } else {
                quote!(#parameter_type)
            };

            // Parameter-Name ()
            let param_name_signature = format_ident!("x{}", arg.to_string());
            let param_name_call = if param_type != "*mut c_char" {
                format_ident!("x{}", arg.to_string())
            } else {
                let code = prepare_char_ptr(&std::format!("x{}", arg.to_string()));
                conversion_code = quote! {
                    #conversion_code
                    #code
                };
                format_ident!("x{}_cptr", arg.to_string())
            };

            arg = arg + 1;
            parameter = quote! {
                #parameter #param_name_signature: #parameter_type,
            };
            parameter_c_binding = quote! {
                #parameter_c_binding #param_name_signature: #parameter_type_c,
            };
            arguments_c_call = quote! {
                #arguments_c_call #param_name_call,
            };
        }

        // Paste everything together
        let (rust_signature, c_binding) = if has_ret_value {
            let rust_signature = quote! {
                pub fn #name(& self, #parameter) -> &#return_type {
                    unsafe {
                        #conversion_code
                        let res: *mut #return_type = #proc_ident(#arguments_c_call self.client);
                        &*res
                    }
                }
            };

            // Create needed C-Binding
            let c_binding = quote! {
                fn #proc_ident (#parameter_c_binding clnt: *mut c_void) -> *mut #return_type;
            };

            (rust_signature, c_binding)
        } else {
            let rust_signature = quote! {
                pub fn #name(& self, #parameter) {
                    unsafe {
                        #conversion_code
                        #proc_ident(#arguments_c_call self.client);
                    }
                }
            };

            // Create needed C-Binding
            let c_binding = quote! {
                fn #proc_ident (#parameter_c_binding clnt: *mut c_void);
            };

            (rust_signature, c_binding)
        };

        (rust_signature, c_binding)
    }
}
